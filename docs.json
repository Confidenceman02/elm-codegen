[{"name":"Elm","comment":"\n\n@docs File, file\n\n\n## Basics\n\n@docs Expression\n\n@docs bool, int, float, char, string, hex, unit\n\n@docs maybe, list, tuple, triple\n\n@docs withType\n\n\n## Records\n\n@docs record, field, Field, get, updateRecord\n\n\n## Flow control\n\n@docs letIn, ifThen\n\n@docs apply\n\n\n## Top level\n\n@docs Declaration\n\n@docs comment, declaration\n\n@docs withDocumentation\n\n@docs fn, fn2, fn3, fn4, fn5, fn6, function, functionReduced\n\n\n## Custom Types\n\n@docs customType, Variant, variant, variantWith\n\n@docs alias\n\n\n## Exposing values\n\nBy default, everything is exposed for your module.\n\nHowever, you can tag specific declarations you want exposed, and then only those things will be exposed.\n\n@docs expose\n\n\n## Grouping exposed values in the module comment\n\nYou can also add a group tag to an exposed value. This will automatically group the `docs` statements in the module docs.\n\nFor precise control over what is rendered for the module comment, use [fileWith](#fileWith)\n\n@docs exposeWith\n\n@docs fileWith, docs\n\n\n# Operators\n\n@docs equal, notEqual\n\n@docs append, cons\n\n@docs plus, minus, multiply, divide, intDivide, power\n\n@docs lt, gt, lte, gte, and, or\n\n\n## Parsing\n\n@docs keep, skip\n\n\n## Url parsing\n\n@docs slash, question\n\n\n# Ports\n\n@docs portIncoming, portOutgoing\n\n\n# Parsing existing Elm\n\n@docs parse, unsafe\n\n\n# Rendering to string\n\n@docs toString, signatureString, expressionImports\n\n@docs declarationToString, declarationImports\n\n\n# Low-level\n\n@docs value, valueFrom\n\n","unions":[{"name":"Field","comment":" ","args":[],"cases":[]},{"name":"Variant","comment":" ","args":[],"cases":[]}],"aliases":[{"name":"Declaration","comment":" ","args":[],"type":"Internal.Compiler.Declaration"},{"name":"Expression","comment":" ","args":[],"type":"Internal.Compiler.Expression"},{"name":"File","comment":" ","args":[],"type":"{ path : String.String, contents : String.String }"}],"values":[{"name":"alias","comment":" A custom type declaration.\n\n    import Elm.Annotation as Type\n\n    Elm.alias \"MyAlias\"\n        (Type.record\n            [ ( \"one\", Type.string )\n            , ( \"two\", Type.int )\n            , ( \"three\", Type.var \"content\" )\n            ]\n        )\n\nShould result in\n\n    type alias MyAlias content =\n        { one : String\n        , two : Int\n        , three : content\n        }\n\n","type":"String.String -> Elm.Annotation.Annotation -> Elm.Declaration"},{"name":"and","comment":" `&&`\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"append","comment":" `++`\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"apply","comment":" ","type":"Elm.Expression -> List.List Elm.Expression -> Elm.Expression"},{"name":"bool","comment":" ","type":"Basics.Bool -> Elm.Expression"},{"name":"char","comment":" ","type":"Char.Char -> Elm.Expression"},{"name":"comment","comment":" ","type":"String.String -> Elm.Declaration"},{"name":"cons","comment":" `::`\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"customType","comment":" A custom type declaration.\n\n    Elm.customType \"MyType\"\n        [ Elm.variant \"One\"\n        , Elm.variantWith \"Two\" [ Elm.Annotation.list Elm.Annotation.string ]\n        ]\n\nWill result in\n\n    type MyType\n        = One\n        | Two (List String)\n\n","type":"String.String -> List.List Elm.Variant -> Elm.Declaration"},{"name":"declaration","comment":" ","type":"String.String -> Elm.Expression -> Elm.Declaration"},{"name":"declarationImports","comment":" ","type":"Elm.Declaration -> String.String"},{"name":"declarationToString","comment":" ","type":"Elm.Declaration -> String.String"},{"name":"divide","comment":" `/`\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"docs","comment":" Render a standard docstring.\n\n    @docs one, two, three\n\n","type":"{ group : Maybe.Maybe String.String, members : List.List String.String } -> String.String"},{"name":"equal","comment":" `==`\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"expose","comment":" ","type":"Elm.Declaration -> Elm.Declaration"},{"name":"exposeWith","comment":" ","type":"{ exposeConstructor : Basics.Bool, group : Maybe.Maybe String.String } -> Elm.Declaration -> Elm.Declaration"},{"name":"expressionImports","comment":" ","type":"Elm.Expression -> String.String"},{"name":"field","comment":" ","type":"String.String -> Elm.Expression -> Elm.Field"},{"name":"file","comment":" Build a file!\n\n    Elm.file [ \"My\", \"Module\" ]\n        [ Elm.declaration \"placeholder\"\n            (Elm.string \"a fancy string!\")\n        ]\n\n","type":"List.List String.String -> List.List Elm.Declaration -> Elm.File"},{"name":"fileWith","comment":" Same as [file](#file), but you have more control over how the module comment is generated!\n\nPass in a function that determines how to render a `@doc` comment.\n\nEach exposed item is grouped based on the string used in [exposeWith](#exposeWith)\n\n","type":"List.List String.String -> { docs : List.List { group : Maybe.Maybe String.String, members : List.List String.String } -> List.List String.String, aliases : List.List ( List.List String.String, String.String ) } -> List.List Elm.Declaration -> Elm.File"},{"name":"float","comment":" ","type":"Basics.Float -> Elm.Expression"},{"name":"fn","comment":" ","type":"String.String -> (Elm.Expression -> Elm.Expression) -> Elm.Expression"},{"name":"fn2","comment":" ","type":"String.String -> String.String -> (Elm.Expression -> Elm.Expression -> Elm.Expression) -> Elm.Expression"},{"name":"fn3","comment":" ","type":"String.String -> String.String -> String.String -> (Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression) -> Elm.Expression"},{"name":"fn4","comment":" ","type":"String.String -> String.String -> String.String -> String.String -> (Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression) -> Elm.Expression"},{"name":"fn5","comment":" ","type":"String.String -> String.String -> String.String -> String.String -> String.String -> (Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression) -> Elm.Expression"},{"name":"fn6","comment":" ","type":"String.String -> String.String -> String.String -> String.String -> String.String -> String.String -> (Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression) -> Elm.Expression"},{"name":"function","comment":"\n\n        Elm.function\n            [ (\"firstArg\", Nothing)\n            , (\"secondArg\", Just Type.string)\n            ]\n            (\\variables ->\n                -- variables is a list of expressions\n                case variables of\n                    [firstArg, secondArg] ->\n                        -- do something with the first and second arg\n                    _ ->\n                        Elm.unit\n\n\n            )\n\n","type":"List.List ( String.String, Maybe.Maybe Elm.Annotation.Annotation ) -> (List.List Elm.Expression -> Elm.Expression) -> Elm.Expression"},{"name":"functionReduced","comment":" ","type":"String.String -> Elm.Annotation.Annotation -> (Elm.Expression -> Elm.Expression) -> Elm.Expression"},{"name":"get","comment":"\n\n    record\n        |> Elm.get \"field\"\n\nresults in\n\n    record.field\n\n","type":"String.String -> Elm.Expression -> Elm.Expression"},{"name":"gt","comment":" `>`\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"gte","comment":" `>=`\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"hex","comment":" ","type":"Basics.Int -> Elm.Expression"},{"name":"ifThen","comment":"\n\n    ifThen (Elm.bool True)\n        (Elm.string \"yes\")\n        (Elm.string \"no\")\n\n    if True then\n        \"yes\"\n\n    else\n        \"no\"\n\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"int","comment":" ","type":"Basics.Int -> Elm.Expression"},{"name":"intDivide","comment":" `//`\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"keep","comment":" used in the `elm/parser` library\n\n`|=`\n\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"letIn","comment":" A let block.\n\nCheck out `Elm.Let` to add things to it.\n\n    import Elm.Let as Let\n\n    Elm.letIn\n        [ (\"one\", (Elm.int 5))\n        , (\"two\", (Elm.int 10))\n        ]\n        (Elm.add (Elm.value \"one\") (Elm.value \"two\"))\n\n","type":"List.List ( String.String, Elm.Expression ) -> Elm.Expression -> Elm.Expression"},{"name":"list","comment":" ","type":"List.List Elm.Expression -> Elm.Expression"},{"name":"lt","comment":" `<`\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"lte","comment":" `<=`\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"maybe","comment":" ","type":"Maybe.Maybe Elm.Expression -> Elm.Expression"},{"name":"minus","comment":" `-`\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"multiply","comment":" `*`\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"notEqual","comment":" `/=`\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"or","comment":" `||`\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"parse","comment":" ","type":"String.String -> Result.Result String.String { declarations : List.List Elm.Declaration }"},{"name":"plus","comment":" `+`\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"portIncoming","comment":"\n\n    import Elm.Annotation as Type\n\n    Elm.portIncoming \"receiveMessageFromTheWorld\"\n        [ Type.string\n        , Type.int\n        ]\n\nResults in\n\n    port receiveMessageFromTheWorld :\n        (String -> Int -> msg)\n        -> Sub msg\n\n**Note** You generally only need one incoming and one outgoing port!\n\nIf you want to vary the messages going in and out of your app, don't use a huge number of ports, instead write Json encoders and decoders.\n\nThis will give you more flexibility in the future and save you having to wire up a bunch of stuff.\n\n**Another note** - You may need to expose your port explicitly using `Elm.expose`\n\n","type":"String.String -> List.List Elm.Annotation.Annotation -> Elm.Declaration"},{"name":"portOutgoing","comment":" Create a port that can send messages to the outside world!\n\n    import Elm.Annotation as Type\n\n    Elm.portOutgoing \"tellTheWorld\" Type.string\n\nwill generate\n\n    port tellTheWorld : String -> Cmd msg\n\n","type":"String.String -> Elm.Annotation.Annotation -> Elm.Declaration"},{"name":"power","comment":" The to-the-power-of operator `^`\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"question","comment":" `<?>` used in url parsing\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"record","comment":" ","type":"List.List Elm.Field -> Elm.Expression"},{"name":"signatureString","comment":" ","type":"Elm.Expression -> String.String"},{"name":"skip","comment":" `|.`\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"slash","comment":" `</>` used in url parsing\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"string","comment":" ","type":"String.String -> Elm.Expression"},{"name":"toString","comment":" ","type":"Elm.Expression -> String.String"},{"name":"triple","comment":" ","type":"Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"tuple","comment":" ","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"unit","comment":" ","type":"Elm.Expression"},{"name":"unsafe","comment":" ","type":"String.String -> Elm.Declaration"},{"name":"updateRecord","comment":" ","type":"String.String -> List.List ( String.String, Elm.Expression ) -> Elm.Expression"},{"name":"value","comment":" ","type":"String.String -> Elm.Expression"},{"name":"valueFrom","comment":" ","type":"List.List String.String -> String.String -> Elm.Expression"},{"name":"variant","comment":" ","type":"String.String -> Elm.Variant"},{"name":"variantWith","comment":" ","type":"String.String -> List.List Elm.Annotation.Annotation -> Elm.Variant"},{"name":"withDocumentation","comment":" Add documentation to a declaration!\n","type":"String.String -> Elm.Declaration -> Elm.Declaration"},{"name":"withType","comment":" Sometimes you may need to add a manual type annotation.\n\n    import Elm.Annotation as Type\n\n    Elm.value \"myString\"\n        |> Elm.withType (Type.string)\n\nThough be sure elm-prefab isn't already doing this automatically for you!\n\n","type":"Elm.Annotation.Annotation -> Elm.Expression -> Elm.Expression"}],"binops":[]},{"name":"Elm.Annotation","comment":"\n\n@docs Annotation, var, bool, int, float, string, char, unit\n\n@docs named, namedWith\n\n@docs maybe, list, tuple, triple, set, dict, result\n\n@docs record, extensible\n\n@docs function\n\n@docs toString\n\n","unions":[],"aliases":[{"name":"Annotation","comment":" ","args":[],"type":"Internal.Compiler.Annotation"}],"values":[{"name":"bool","comment":" ","type":"Elm.Annotation.Annotation"},{"name":"char","comment":" ","type":"Elm.Annotation.Annotation"},{"name":"dict","comment":" ","type":"Elm.Annotation.Annotation -> Elm.Annotation.Annotation -> Elm.Annotation.Annotation"},{"name":"extensible","comment":" ","type":"String.String -> List.List ( String.String, Elm.Annotation.Annotation ) -> Elm.Annotation.Annotation"},{"name":"float","comment":" ","type":"Elm.Annotation.Annotation"},{"name":"function","comment":" ","type":"List.List Elm.Annotation.Annotation -> Elm.Annotation.Annotation -> Elm.Annotation.Annotation"},{"name":"int","comment":" ","type":"Elm.Annotation.Annotation"},{"name":"list","comment":" ","type":"Elm.Annotation.Annotation -> Elm.Annotation.Annotation"},{"name":"maybe","comment":" ","type":"Elm.Annotation.Annotation -> Elm.Annotation.Annotation"},{"name":"named","comment":" ","type":"List.List String.String -> String.String -> Elm.Annotation.Annotation"},{"name":"namedWith","comment":" ","type":"List.List String.String -> String.String -> List.List Elm.Annotation.Annotation -> Elm.Annotation.Annotation"},{"name":"record","comment":" ","type":"List.List ( String.String, Elm.Annotation.Annotation ) -> Elm.Annotation.Annotation"},{"name":"result","comment":" ","type":"Elm.Annotation.Annotation -> Elm.Annotation.Annotation -> Elm.Annotation.Annotation"},{"name":"set","comment":" ","type":"Elm.Annotation.Annotation -> Elm.Annotation.Annotation"},{"name":"string","comment":" ","type":"Elm.Annotation.Annotation"},{"name":"toString","comment":" ","type":"Elm.Annotation.Annotation -> String.String"},{"name":"triple","comment":" ","type":"Elm.Annotation.Annotation -> Elm.Annotation.Annotation -> Elm.Annotation.Annotation -> Elm.Annotation.Annotation"},{"name":"tuple","comment":" ","type":"Elm.Annotation.Annotation -> Elm.Annotation.Annotation -> Elm.Annotation.Annotation"},{"name":"unit","comment":" ","type":"Elm.Annotation.Annotation"},{"name":"var","comment":" A type variable\n","type":"String.String -> Elm.Annotation.Annotation"}],"binops":[]},{"name":"Elm.Case","comment":"\n\n@docs maybe, result, list, list2, list3\n\n@docs tuple, triple\n\n@docs custom\n\n@docs Branch, otherwise, branch, branch2, branch3, branch4, branch5\n\n","unions":[{"name":"Branch","comment":" ","args":[],"cases":[]}],"aliases":[],"values":[{"name":"branch","comment":" ","type":"String.String -> Elm.Expression -> Elm.Case.Branch"},{"name":"branch2","comment":" ","type":"String.String -> (Elm.Expression -> Elm.Expression) -> Elm.Case.Branch"},{"name":"branch3","comment":" ","type":"String.String -> (Elm.Expression -> Elm.Expression -> Elm.Expression) -> Elm.Case.Branch"},{"name":"branch4","comment":" ","type":"String.String -> (Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression) -> Elm.Case.Branch"},{"name":"branch5","comment":" ","type":"String.String -> (Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression) -> Elm.Case.Branch"},{"name":"custom","comment":" ","type":"Elm.Expression -> List.List Elm.Case.Branch -> Elm.Expression"},{"name":"list","comment":" ","type":"Elm.Expression -> { empty : Elm.Expression, remaining : Elm.Expression -> Elm.Expression } -> Elm.Expression"},{"name":"list2","comment":" ","type":"Elm.Expression -> { empty : Elm.Expression, one : Elm.Expression -> Elm.Expression, remaining : Elm.Expression -> Elm.Expression } -> Elm.Expression"},{"name":"list3","comment":" ","type":"Elm.Expression -> { empty : Elm.Expression, one : Elm.Expression -> Elm.Expression, two : Elm.Expression -> Elm.Expression -> Elm.Expression, remaining : Elm.Expression -> Elm.Expression } -> Elm.Expression"},{"name":"maybe","comment":" ","type":"Elm.Expression -> { nothing : Elm.Expression, just : Elm.Expression -> Elm.Expression } -> Elm.Expression"},{"name":"otherwise","comment":"\n\n    A catchall branch in case you want the case to be nonexhaustive.\n\n","type":"(Elm.Expression -> Elm.Expression) -> Elm.Case.Branch"},{"name":"result","comment":" ","type":"Elm.Expression -> { err : Elm.Expression -> Elm.Expression, ok : Elm.Expression -> Elm.Expression } -> Elm.Expression"},{"name":"triple","comment":" ","type":"Elm.Expression -> (Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression) -> Elm.Expression"},{"name":"tuple","comment":" ","type":"Elm.Expression -> (Elm.Expression -> Elm.Expression -> Elm.Expression) -> Elm.Expression"}],"binops":[]},{"name":"Error.Format","comment":"\n\n@docs block\n\n@docs cyan, yellow, green, red, grey\n\n","unions":[],"aliases":[],"values":[{"name":"block","comment":" An indented block with a newline above and below\n","type":"List.List String.String -> String.String"},{"name":"cyan","comment":" ","type":"String.String -> String.String"},{"name":"green","comment":" ","type":"String.String -> String.String"},{"name":"grey","comment":" ","type":"String.String -> String.String"},{"name":"red","comment":" ","type":"String.String -> String.String"},{"name":"yellow","comment":" ","type":"String.String -> String.String"}],"binops":[]}]