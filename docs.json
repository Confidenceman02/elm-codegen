[{"name":"Elm","comment":"\n\n@docs File, file\n\n\n## Basics\n\n@docs Expression\n\n@docs bool, int, float, char, string, hex, unit\n\n@docs maybe, list, tuple, triple\n\n@docs value, valueFrom, valueWith\n\n@docs withType\n\n\n## Records\n\n@docs record, field, Field, get, updateRecord\n\n\n## Flow control\n\n@docs caseOf, letIn, ifThen\n\n@docs apply\n\n@docs lambda, lambda2, lambda3, lambda4, lambda5, lambdaWith\n\n\n## Top level\n\n@docs Declaration\n\n@docs comment, declaration\n\n@docs withDocumentation\n\n@docs fn, fn2, fn3, fn4, fn5, functionWith\n\n\n## Custom Types\n\n@docs customType, Variant, variant, variantWith\n\n@docs alias\n\n\n## Exposing values\n\nBy default, everything is exposed for your module.\n\nHowever, you can tag specific declarations you want exposed, and then only those things will be exposed.\n\n@docs expose, exposeConstructor\n\n\n## Grouping exposed values in the module comment\n\nYou can also add a group tag to an exposed value. This will automatically group the `docs` statements in the module docs.\n\nFor precise control over what is rendered for the module comment, use [fileWith](#fileWith)\n\n@docs exposeAndGroup, exposeConstructorAndGroup\n\n@docs fileWith\n\n\n# Operators\n\n@docs equal, notEqual\n\n@docs append, cons\n\n@docs plus, minus, multiply, divide, intDivide, power\n\n@docs lt, gt, lte, gte, and, or\n\n@docs pipe, pipeLeft, compose, composeLeft\n\n\n## Parsing\n\n@docs keep, skip\n\n\n## Url parsing\n\n@docs slash, question\n\n\n# Ports\n\n@docs portIncoming, portOutgoing\n\n\n# Parsing existing Elm\n\n@docs parse\n\n\n# Rendering to string\n\n@docs toString, expressionImports\n\n@docs declarationToString, declarationImports\n\n@docs pass\n\n","unions":[{"name":"Field","comment":" ","args":[],"cases":[]},{"name":"Variant","comment":" ","args":[],"cases":[]}],"aliases":[{"name":"Declaration","comment":" ","args":[],"type":"Internal.Compiler.Declaration"},{"name":"Expression","comment":" ","args":[],"type":"Internal.Compiler.Expression"},{"name":"File","comment":" ","args":[],"type":"{ path : String.String, contents : String.String }"}],"values":[{"name":"alias","comment":" A custom type declaration.\n\n    import Elm.Annotation as Type\n\n    Elm.alias \"MyAlias\"\n        (Type.record\n            [ ( \"one\", Type.string )\n            , ( \"two\", Type.int )\n            , ( \"three\", Type.var \"content\" )\n            ]\n        )\n\nShould result in\n\n    type alias MyAlias content =\n        { one : String\n        , two : Int\n        , three : content\n        }\n\n","type":"String.String -> Elm.Annotation.Annotation -> Elm.Declaration"},{"name":"and","comment":" `&&`\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"append","comment":" `++`\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"apply","comment":" ","type":"Elm.Expression -> List.List Elm.Expression -> Elm.Expression"},{"name":"bool","comment":" ","type":"Basics.Bool -> Elm.Expression"},{"name":"caseOf","comment":" ","type":"Elm.Expression -> List.List ( Elm.Pattern, Elm.Expression ) -> Elm.Expression"},{"name":"char","comment":" ","type":"Char.Char -> Elm.Expression"},{"name":"comment","comment":" ","type":"String.String -> Elm.Declaration"},{"name":"compose","comment":" `>>`\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"composeLeft","comment":" `<<`\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"cons","comment":" `::`\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"customType","comment":" A custom type declaration.\n\n    Elm.customType \"MyType\"\n        [ Elm.variant \"One\"\n        , Elm.variantWith \"Two\" [ Elm.Annotation.list Elm.Annotation.string ]\n        ]\n\nWill result in\n\n    type MyType\n        = One\n        | Two (List String)\n\n","type":"String.String -> List.List Elm.Variant -> Elm.Declaration"},{"name":"declaration","comment":" ","type":"String.String -> Elm.Expression -> Elm.Declaration"},{"name":"declarationImports","comment":" ","type":"Elm.Declaration -> String.String"},{"name":"declarationToString","comment":" ","type":"Elm.Declaration -> String.String"},{"name":"divide","comment":" `/`\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"equal","comment":" `==`\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"expose","comment":" ","type":"Elm.Declaration -> Elm.Declaration"},{"name":"exposeAndGroup","comment":" ","type":"String.String -> Elm.Declaration -> Elm.Declaration"},{"name":"exposeConstructor","comment":" ","type":"Elm.Declaration -> Elm.Declaration"},{"name":"exposeConstructorAndGroup","comment":" ","type":"String.String -> Elm.Declaration -> Elm.Declaration"},{"name":"expressionImports","comment":" ","type":"Elm.Expression -> String.String"},{"name":"field","comment":" ","type":"String.String -> Elm.Expression -> Elm.Field"},{"name":"file","comment":" Build a file!\n\n    Elm.file [ \"My\", \"Module\" ]\n        [ Elm.declaration \"placeholder\"\n            (Elm.string \"a fancy string!\")\n        ]\n\n","type":"List.List String.String -> List.List Elm.Declaration -> Elm.File"},{"name":"fileWith","comment":" Same as [file](#file), but you have more control over how the module comment is generated!\n\nPass in a function that determines how to render a `@doc` comment.\n\nEach exposed item is grouped based on the string used in [exposeAndGroup](#exposeAndGroup)\n\n","type":"List.List String.String -> { docs : List.List { group : Maybe.Maybe String.String, members : List.List String.String } -> String.String, aliases : List.List ( List.List String.String, String.String ) } -> List.List Elm.Declaration -> Elm.File"},{"name":"float","comment":" ","type":"Basics.Float -> Elm.Expression"},{"name":"fn","comment":" ","type":"String.String -> ( String.String, Elm.Annotation.Annotation ) -> (Elm.Expression -> Elm.Expression) -> Elm.Declaration"},{"name":"fn2","comment":" ","type":"String.String -> ( String.String, Elm.Annotation.Annotation ) -> ( String.String, Elm.Annotation.Annotation ) -> (Elm.Expression -> Elm.Expression -> Elm.Expression) -> Elm.Declaration"},{"name":"fn3","comment":" ","type":"String.String -> ( String.String, Elm.Annotation.Annotation ) -> ( String.String, Elm.Annotation.Annotation ) -> ( String.String, Elm.Annotation.Annotation ) -> (Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression) -> Elm.Declaration"},{"name":"fn4","comment":" ","type":"String.String -> ( String.String, Elm.Annotation.Annotation ) -> ( String.String, Elm.Annotation.Annotation ) -> ( String.String, Elm.Annotation.Annotation ) -> ( String.String, Elm.Annotation.Annotation ) -> (Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression) -> Elm.Declaration"},{"name":"fn5","comment":" ","type":"String.String -> ( String.String, Elm.Annotation.Annotation ) -> ( String.String, Elm.Annotation.Annotation ) -> ( String.String, Elm.Annotation.Annotation ) -> ( String.String, Elm.Annotation.Annotation ) -> ( String.String, Elm.Annotation.Annotation ) -> (Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression) -> Elm.Declaration"},{"name":"functionWith","comment":" ","type":"String.String -> List.List ( Elm.Annotation.Annotation, Elm.Pattern ) -> Elm.Expression -> Elm.Declaration"},{"name":"get","comment":"\n\n    record\n        |> Elm.get \"field\"\n\nresults in\n\n    record.field\n\n","type":"String.String -> Elm.Expression -> Elm.Expression"},{"name":"gt","comment":" `>`\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"gte","comment":" `>=`\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"hex","comment":" ","type":"Basics.Int -> Elm.Expression"},{"name":"ifThen","comment":"\n\n    ifThen (Elm.bool True)\n        (Elm.string \"yes\")\n        (Elm.string \"no\")\n\n    if True then\n        \"yes\"\n\n    else\n        \"no\"\n\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"int","comment":" ","type":"Basics.Int -> Elm.Expression"},{"name":"intDivide","comment":" `//`\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"keep","comment":" used in the `elm/parser` library\n\n`|=`\n\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"lambda","comment":" ","type":"String.String -> Elm.Annotation.Annotation -> (Elm.Expression -> Elm.Expression) -> Elm.Expression"},{"name":"lambda2","comment":" ","type":"String.String -> Elm.Annotation.Annotation -> Elm.Annotation.Annotation -> (Elm.Expression -> Elm.Expression -> Elm.Expression) -> Elm.Expression"},{"name":"lambda3","comment":" ","type":"String.String -> Elm.Annotation.Annotation -> Elm.Annotation.Annotation -> Elm.Annotation.Annotation -> (Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression) -> Elm.Expression"},{"name":"lambda4","comment":" ","type":"String.String -> Elm.Annotation.Annotation -> Elm.Annotation.Annotation -> Elm.Annotation.Annotation -> Elm.Annotation.Annotation -> (Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression) -> Elm.Expression"},{"name":"lambda5","comment":" ","type":"String.String -> Elm.Annotation.Annotation -> Elm.Annotation.Annotation -> Elm.Annotation.Annotation -> Elm.Annotation.Annotation -> Elm.Annotation.Annotation -> (Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression) -> Elm.Expression"},{"name":"lambdaWith","comment":" ","type":"List.List ( Elm.Pattern, Elm.Annotation.Annotation ) -> Elm.Expression -> Elm.Expression"},{"name":"letIn","comment":" A let block.\n\nCheck out `Elm.Let` to add things to it.\n\n    import Elm.Let as Let\n\n    Elm.letIn\n        [ Let.value \"one\" (Elm.int 5)\n        , Let.value \"two\" (Elm.int 10)\n        ]\n        (Elm.add (Elm.value \"one\") (Elm.value \"two\"))\n\n","type":"List.List Elm.Let.Declaration -> Elm.Expression -> Elm.Expression"},{"name":"list","comment":" ","type":"List.List Elm.Expression -> Elm.Expression"},{"name":"lt","comment":" `<`\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"lte","comment":" `<=`\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"maybe","comment":" ","type":"Maybe.Maybe Elm.Expression -> Elm.Expression"},{"name":"minus","comment":" `-`\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"multiply","comment":" `*`\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"notEqual","comment":" `/=`\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"or","comment":" `||`\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"parse","comment":" ","type":"String.String -> Result.Result String.String { declarations : List.List Elm.Declaration }"},{"name":"pass","comment":" ","type":"Elm.Expression"},{"name":"pipe","comment":" `|>`\n\n    Elm.value \"thang\"\n        |> Elm.pipe (Elm.value \"thang2\")\n        |> Elm.pipe (Elm.value \"thang3\")\n\nResults in\n\n    thang\n        |> thang2\n        |> thang3\n\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"pipeLeft","comment":" `<|`\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"plus","comment":" `+`\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"portIncoming","comment":"\n\n    import Elm.Annotation as Type\n\n    Elm.portIncoming \"receiveMessageFromTheWorld\"\n        [ Type.string\n        , Type.int\n        ]\n\nResults in\n\n    port receiveMessageFromTheWorld :\n            (String -> Int -> msg)\n                -> Sub msg\n\n**Note** You generally only need one incoming and one outgoing port!\n\nIf you want to vary the messages going in and out of your app, don't use a huge number of ports, instead write Json encoders and decoders.\n\nThis will give you more flexibility in the future and save you having to wire up a bunch of stuff.\n\n**Another note** - You may need to expose your port explicitly using `Elm.expose`\n\n","type":"String.String -> List.List Elm.Annotation.Annotation -> Elm.Declaration"},{"name":"portOutgoing","comment":" Create a port that can send messages to the outside world!\n\n    import Elm.Annotation as Type\n\n    Elm.portOutgoing \"tellTheWorld\" Type.string\n\nwill generate\n\n    port tellTheWorld : String -> Cmd msg\n\n","type":"String.String -> Elm.Annotation.Annotation -> Elm.Declaration"},{"name":"power","comment":" The to-the-power-of operator `^`\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"question","comment":" `<?>` used in url parsing\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"record","comment":" ","type":"List.List Elm.Field -> Elm.Expression"},{"name":"skip","comment":" `|.`\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"slash","comment":" `</>` used in url parsing\n","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"string","comment":" ","type":"String.String -> Elm.Expression"},{"name":"toString","comment":" ","type":"Elm.Expression -> String.String"},{"name":"triple","comment":" ","type":"Elm.Expression -> Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"tuple","comment":" ","type":"Elm.Expression -> Elm.Expression -> Elm.Expression"},{"name":"unit","comment":" ","type":"Elm.Expression"},{"name":"updateRecord","comment":" ","type":"String.String -> List.List ( String.String, Elm.Expression ) -> Elm.Expression"},{"name":"value","comment":" ","type":"String.String -> Elm.Expression"},{"name":"valueFrom","comment":" ","type":"List.List String.String -> String.String -> Elm.Expression"},{"name":"valueWith","comment":" Add an annotation to a value.\n\n**Note** this may not _literally_ add an annotation to the code, but will inform `elm-prefab`s type inference so that top level values can be auto-annotated.\n\nSo, for example, if we have.\n\n    Elm.list\n        [ Elm.valueWith myModule \"myString\" Elm.Annotation.string\n        , Elm.valueWith myModule \"myOtherString\" Elm.Annotation.string\n        ]\n\nThen, when that list is generated, it will automatically have the type signature `List String`\n\n","type":"List.List String.String -> String.String -> Elm.Annotation.Annotation -> Elm.Expression"},{"name":"variant","comment":" ","type":"String.String -> Elm.Variant"},{"name":"variantWith","comment":" ","type":"String.String -> List.List Elm.Annotation.Annotation -> Elm.Variant"},{"name":"withDocumentation","comment":" Add documentation to a declaration!\n","type":"String.String -> Elm.Declaration -> Elm.Declaration"},{"name":"withType","comment":" Sometimes you may need to add a manual type annotation.\n\n    import Elm.Annotation as Type\n\n    Elm.value \"myString\"\n        |> Elm.withType (Type.string)\n\nThough be sure elm-prefab isn't already doing this automatically for you!\n\n","type":"Elm.Annotation.Annotation -> Elm.Expression -> Elm.Expression"}],"binops":[]},{"name":"Elm.Annotation","comment":"\n\n@docs Annotation, var, bool, int, float, string, char, unit\n\n@docs named, namedWith\n\n@docs maybe, list, tuple, triple, set, dict, result\n\n@docs record, extensible\n\n@docs function\n\n@docs toString\n\n","unions":[],"aliases":[{"name":"Annotation","comment":" ","args":[],"type":"Internal.Compiler.Annotation"}],"values":[{"name":"bool","comment":" ","type":"Elm.Annotation.Annotation"},{"name":"char","comment":" ","type":"Elm.Annotation.Annotation"},{"name":"dict","comment":" ","type":"Elm.Annotation.Annotation -> Elm.Annotation.Annotation -> Elm.Annotation.Annotation"},{"name":"extensible","comment":" ","type":"String.String -> List.List ( String.String, Elm.Annotation.Annotation ) -> Elm.Annotation.Annotation"},{"name":"float","comment":" ","type":"Elm.Annotation.Annotation"},{"name":"function","comment":" ","type":"List.List Elm.Annotation.Annotation -> Elm.Annotation.Annotation -> Elm.Annotation.Annotation"},{"name":"int","comment":" ","type":"Elm.Annotation.Annotation"},{"name":"list","comment":" ","type":"Elm.Annotation.Annotation -> Elm.Annotation.Annotation"},{"name":"maybe","comment":" ","type":"Elm.Annotation.Annotation -> Elm.Annotation.Annotation"},{"name":"named","comment":" ","type":"List.List String.String -> String.String -> Elm.Annotation.Annotation"},{"name":"namedWith","comment":" ","type":"List.List String.String -> String.String -> List.List Elm.Annotation.Annotation -> Elm.Annotation.Annotation"},{"name":"record","comment":" ","type":"List.List ( String.String, Elm.Annotation.Annotation ) -> Elm.Annotation.Annotation"},{"name":"result","comment":" ","type":"Elm.Annotation.Annotation -> Elm.Annotation.Annotation -> Elm.Annotation.Annotation"},{"name":"set","comment":" ","type":"Elm.Annotation.Annotation -> Elm.Annotation.Annotation"},{"name":"string","comment":" ","type":"Elm.Annotation.Annotation"},{"name":"toString","comment":" ","type":"Elm.Annotation.Annotation -> String.String"},{"name":"triple","comment":" ","type":"Elm.Annotation.Annotation -> Elm.Annotation.Annotation -> Elm.Annotation.Annotation -> Elm.Annotation.Annotation"},{"name":"tuple","comment":" ","type":"Elm.Annotation.Annotation -> Elm.Annotation.Annotation -> Elm.Annotation.Annotation"},{"name":"unit","comment":" ","type":"Elm.Annotation.Annotation"},{"name":"var","comment":" A type variable\n","type":"String.String -> Elm.Annotation.Annotation"}],"binops":[]},{"name":"Elm.Debug","comment":"\n\n@docs annotation\n\n","unions":[],"aliases":[],"values":[{"name":"annotation","comment":" Print out what elm-prefab thinks the type signature is at any given point.\n","type":"(String.String -> Result.Result (List.List Internal.Compiler.InferenceError) Elm.Syntax.TypeAnnotation.TypeAnnotation -> Result.Result (List.List Internal.Compiler.InferenceError) Elm.Syntax.TypeAnnotation.TypeAnnotation) -> String.String -> Elm.Debug.Expression -> Elm.Debug.Expression"}],"binops":[]},{"name":"Elm.Let","comment":"\n\n@docs Declaration, value, destructure\n\n@docs function\n\n","unions":[],"aliases":[{"name":"Declaration","comment":" ","args":[],"type":"Internal.Compiler.LetDeclaration"}],"values":[{"name":"destructure","comment":" ","type":"Elm.Pattern.Pattern -> Elm.Let.Expression -> Elm.Let.Declaration"},{"name":"function","comment":" ","type":"String.String -> List.List Elm.Pattern.Pattern -> Elm.Let.Expression -> Elm.Let.Declaration"},{"name":"value","comment":" ","type":"String.String -> Elm.Let.Expression -> Elm.Let.Declaration"}],"binops":[]},{"name":"Elm.Pattern","comment":"\n\n@docs Pattern, var, unit, char, string, int, hex, float\n\n@docs tuple, triple, fields, cons, list, named, namedFrom, withAlias\n\n@docs wildcard\n\n","unions":[],"aliases":[{"name":"Pattern","comment":" ","args":[],"type":"Elm.Syntax.Pattern.Pattern"}],"values":[{"name":"char","comment":"\n\n    'c'\n\n","type":"Char.Char -> Elm.Pattern.Pattern"},{"name":"cons","comment":" ","type":"Elm.Pattern.Pattern -> Elm.Pattern.Pattern -> Elm.Pattern.Pattern"},{"name":"fields","comment":"\n\n    Elm.Pattern.fields\n        [ \"field1\"\n        , \"field2\"\n        ]\n\nresults in\n\n    { field1, field2}\n\n","type":"List.List String.String -> Elm.Pattern.Pattern"},{"name":"float","comment":" ","type":"Basics.Float -> Elm.Pattern.Pattern"},{"name":"hex","comment":"\n\n    0x11\n\n","type":"Basics.Int -> Elm.Pattern.Pattern"},{"name":"int","comment":" ","type":"Basics.Int -> Elm.Pattern.Pattern"},{"name":"list","comment":" ","type":"List.List Elm.Pattern.Pattern -> Elm.Pattern.Pattern"},{"name":"named","comment":"\n\n    Elm.Pattern.named \"Just\" [ Elm.Pattern.var \"value\" ]\n\nwould result in the following unpacking\n\n    Just value\n\n","type":"String.String -> List.List Elm.Pattern.Pattern -> Elm.Pattern.Pattern"},{"name":"namedFrom","comment":" Same as `named`, but from a specific module.\n\n    result = Elm.moduleName [\"Result\" ]\n\n    Elm.Pattern.namedFrom result \"Ok\" [ Elm.Pattern.var \"value\" ]\n\nwould result in\n\n    Result.Ok value\n\n","type":"List.List String.String -> String.String -> List.List Elm.Pattern.Pattern -> Elm.Pattern.Pattern"},{"name":"string","comment":" ","type":"String.String -> Elm.Pattern.Pattern"},{"name":"triple","comment":" ","type":"Elm.Pattern.Pattern -> Elm.Pattern.Pattern -> Elm.Pattern.Pattern -> Elm.Pattern.Pattern"},{"name":"tuple","comment":"\n\n    Elm.Pattern.tuple\n        (Elm.Pattern.var \"one\")\n        (Elm.Pattern.var \"two\")\n\nresults in\n\n    ( one, two )\n\n","type":"Elm.Pattern.Pattern -> Elm.Pattern.Pattern -> Elm.Pattern.Pattern"},{"name":"unit","comment":"\n\n    `()`\n\n","type":"Elm.Pattern.Pattern"},{"name":"var","comment":" A simple variable name!\n\nThis is what you want 90% of the time.\n\n","type":"String.String -> Elm.Pattern.Pattern"},{"name":"wildcard","comment":" The catchall `_` pattern.\n","type":"Elm.Pattern.Pattern"},{"name":"withAlias","comment":" This is equivalent to `as` in Elm.\n\nSometimes you want to unpack some stuff, but also keep a reference to the top level thing.\n\n    Pattern.withAlias \"fullTuple\"\n        (Pattern.tuple\n            (Pattern.var \"one\")\n            (Pattern.var \"two\")\n        )\n\nresults in\n\n    ((one, two) as fullTuple)\n\n","type":"String.String -> Elm.Pattern.Pattern -> Elm.Pattern.Pattern"}],"binops":[]}]